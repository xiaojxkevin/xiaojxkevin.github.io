<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://xiaojxkevin.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xiaojxkevin.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-03-27T05:47:00+00:00</updated><id>https://xiaojxkevin.github.io/feed.xml</id><title type="html">Jinxi’s Home</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Josephus Problem</title><link href="https://xiaojxkevin.github.io/blog/2024/josephus/" rel="alternate" type="text/html" title="Josephus Problem"/><published>2024-03-27T00:00:00+00:00</published><updated>2024-03-27T00:00:00+00:00</updated><id>https://xiaojxkevin.github.io/blog/2024/josephus</id><content type="html" xml:base="https://xiaojxkevin.github.io/blog/2024/josephus/"><![CDATA[<h2 id="问题描述">问题描述</h2> <blockquote> <p>社团共有 <code class="language-plaintext highlighter-rouge">n</code> 位成员参与破冰游戏，编号为 <code class="language-plaintext highlighter-rouge">0 ~ n-1</code>。成员们按照编号顺序围绕圆桌而坐。社长抽取一个数字 <code class="language-plaintext highlighter-rouge">m</code>，从 <code class="language-plaintext highlighter-rouge">0</code> 号成员起开始计数，排在第 <code class="language-plaintext highlighter-rouge">m</code> 位的成员离开圆桌，且成员离开后从下一个成员开始计数。请返回游戏结束时最后一位成员（赢家）的编号。</p> </blockquote> <blockquote> <p>保证\(m\geq 1\), \(n \geq 1\) 以及<code class="language-plaintext highlighter-rouge">m, n</code>为<code class="language-plaintext highlighter-rouge">int</code>类型。</p> </blockquote> <h2 id="问题分析">问题分析</h2> <p>首先需要明确一个概念：我们要求的编号与索引是不同的，每次一次迭代的索引都是从0开始。但是注意到在迭代开始的时候，我们的索引与编号是完全一致的。那么就会引申出两种解法。</p> <h3 id="模拟过程">模拟过程</h3> <p>我们不妨建一个循环的链表，即最后链表的<code class="language-plaintext highlighter-rouge">next</code>指向<code class="language-plaintext highlighter-rouge">head</code>，然后不断模拟整个游戏的过程。这个方法必然能稳定得出正确的结果，但其时间复杂度在\(O(n^2)\)，空间复杂度在\(O(n)\)。当数据规模很大时它的表现就会比较差。</p> <h3 id="状态转移">状态转移</h3> <p>对于圆这种可以无限循环的数据结构而言，有一个巧妙的方法是取模，然后构造两个并排的列表（中间用<code class="language-plaintext highlighter-rouge">|</code>隔开）：</p> <p></p> <table> <thead> <tr> <th>0</th> <th>…</th> <th>n-1</th> <th>|</th> <th>0</th> <th>…</th> <th>n-1</th> </tr> </thead> <tbody> <tr> <td>this</td> <td>line</td> <td>is</td> <td>left</td> <td>empty</td> <td>for</td> <td>purpose</td> </tr> </tbody> </table> <p></p> <p>这样一来，给定任意一个要删除的索引<code class="language-plaintext highlighter-rouge">k</code>（<code class="language-plaintext highlighter-rouge">k</code>必然在<code class="language-plaintext highlighter-rouge">0 ~ n-1</code>之间，不失一般性我们假定<code class="language-plaintext highlighter-rouge">k</code>不在边界处） ，我们可以很简单地构造下一阶段的并排列表：</p> <p></p> <table> <thead> <tr> <th>n:</th> <th>0</th> <th>…</th> <th>k</th> <th>…</th> <th>|</th> <th>0</th> <th>…</th> <th>k</th> <th>…</th> </tr> </thead> <tbody> <tr> <td><strong>n-1:</strong></td> <td><strong>k+1</strong></td> <td><strong>…</strong></td> <td><strong>0</strong></td> <td><strong>…</strong></td> <td><strong>k-1</strong></td> <td><strong>|</strong></td> <td><strong>k+1</strong></td> <td><strong>…</strong></td> <td> </td> </tr> </tbody> </table> <p></p> <p>我们可以总结出一个规律：对于每一次迭代，我们就相当于扔掉前面<code class="language-plaintext highlighter-rouge">k</code>个元素，再向后数对应<code class="language-plaintext highlighter-rouge">n-1</code>个，数完了以后再复制这<code class="language-plaintext highlighter-rouge">n-1</code>个构造出并排的列表。</p> <p>定义\(f(x):\) 成员个数为\(x\)时赢家在并排列表中的 <strong>索引</strong>（由于是并排的，我们只需要关注前半部分就OK了），注意到赢家是不会被删除的，因此\(x\)的取值在 \(1, 2, 3, ..., n\)。</p> <p>注意到\(f(x)\)有两个特殊之处：</p> <ol> <li>\(f(1) = 0\);</li> <li>\(f(n)\)就是我们最终要求的赢家的编号。</li> </ol> <p>那么现在的任务就是去求得 \(f(n)\)，自然地，我们希望能找到一个合适的递推公式，这样就可以求解了。</p> <p>当前成员人数为<code class="language-plaintext highlighter-rouge">t</code>时，我们用<code class="language-plaintext highlighter-rouge">X</code>表示被删除的编号，<code class="language-plaintext highlighter-rouge">S</code>表示即将成为索引为0的编号，<code class="language-plaintext highlighter-rouge">*</code>表示赢家的编号。具体过程如下：</p> <p></p> <table> <thead> <tr> <th><code class="language-plaintext highlighter-rouge">t:</code></th> <th>…</th> <th>X</th> <th>S</th> <th>…</th> <th>*</th> <th>…</th> <th>|</th> <th>…</th> </tr> </thead> <tbody> <tr> <td><strong><code class="language-plaintext highlighter-rouge">t-1:</code></strong></td> <td><strong>S</strong></td> <td><strong>…</strong></td> <td><strong>*</strong></td> <td><strong>…</strong></td> <td><strong>|</strong></td> <td><strong>…</strong></td> <td> </td> <td> </td> </tr> </tbody> </table> <p></p> <p>注意到<code class="language-plaintext highlighter-rouge">S</code>在<code class="language-plaintext highlighter-rouge">t-1</code>的索引为<code class="language-plaintext highlighter-rouge">0</code>，在<code class="language-plaintext highlighter-rouge">t</code>的索引为 \(m\%t\)。于是乎，我们能找到两个状态之间的平移量：\(m\%t\)。已知<code class="language-plaintext highlighter-rouge">*</code>的索引在<code class="language-plaintext highlighter-rouge">t-1</code>状态时为\(f(t-1)\)，那么我们可以恢复出它在<code class="language-plaintext highlighter-rouge">t</code>状态时的索引：\(m\%t+f(t-1)\)。为防止越界，我们取模，得到状态转移方程</p> \[f(t) = [m\%t+f(t-1)]\%t\] <p>鉴于我们已知\(f(1)\)，我们可以直接写一个循环求解:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">i</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>该算法时间复杂度\(O(n)\)，空间复杂度为\(O(1)\)。</p> <h2 id="参考资料">参考资料</h2> <ol> <li><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/</a></li> <li><a href="https://oi-wiki.org/misc/josephus/">https://oi-wiki.org/misc/josephus/</a></li> </ol>]]></content><author><name></name></author><category term="algorithm"/><summary type="html"><![CDATA[The solution.]]></summary></entry><entry><title type="html">Linear Programming</title><link href="https://xiaojxkevin.github.io/blog/2024/opt-lp/" rel="alternate" type="text/html" title="Linear Programming"/><published>2024-03-26T00:00:00+00:00</published><updated>2024-03-26T00:00:00+00:00</updated><id>https://xiaojxkevin.github.io/blog/2024/opt-lp</id><content type="html" xml:base="https://xiaojxkevin.github.io/blog/2024/opt-lp/"><![CDATA[<p>Redirecting to <code class="language-plaintext highlighter-rouge">Linear_Programming.pdf</code></p>]]></content><author><name></name></author><category term="math"/><summary type="html"><![CDATA[Notes for course SI152 at ShanghaiTech]]></summary></entry><entry><title type="html">Pose Graph 1</title><link href="https://xiaojxkevin.github.io/blog/2024/pose-graph-1/" rel="alternate" type="text/html" title="Pose Graph 1"/><published>2024-03-22T00:00:00+00:00</published><updated>2024-03-22T00:00:00+00:00</updated><id>https://xiaojxkevin.github.io/blog/2024/pose-graph-1</id><content type="html" xml:base="https://xiaojxkevin.github.io/blog/2024/pose-graph-1/"><![CDATA[<h3 id="notations">Notations</h3> <p><em>please ignore this if you haven’t seen contents below</em></p> <ul> <li> <p>\(x_{i} =[ t_{x} ,t_{y} ,t_{z} ,\theta_{x} ,\theta_{y} ,\theta_{z}]^{T} \in \mathbb{R}^6\) to be a state, and \(T_{i}\) is the corresponding transformation function in \(SE(3)\), where</p> \[T_{i} \ =\ \begin{bmatrix} R_{i} &amp; t_{i}\\ 0 &amp; 1 \end{bmatrix}\] </li> <li> <p><em>t2v()</em> is a function that maps a state to its corresponding transformation matrix; and <em>v2t()</em> is exactly the inverse function.</p> </li> <li> <p>\(x = [x_{1}^{T} , ..., x_{n}^{T}]\) to be the state vector of \(n\) states.</p> </li> <li> <p>\(\displaystyle Z_{ij} \ \in \ SE( 3)\) to be the measured transformation matrix from scan \(\displaystyle i\) to scan \(\displaystyle j\) (like the reslult of using ICP to match two scans). And we define \(\displaystyle z_{ij} \ =\ t2v( Z_{ij})\).</p> \[Z_{ij} \ =\ \begin{bmatrix} R_{ij} &amp; t_{ij}\\ 0 &amp; 1 \end{bmatrix}\] </li> <li> <p>Define \(\displaystyle \tilde{Z}_{ij} \ =\ T_{i}^{-1} T_{j}\) to be the relative pose via two states, and \(\displaystyle \tilde{z}_{ij} \ =\ t2v\left(\tilde{Z}_{ij}\right)\).</p> </li> <li> <p>Define \(\displaystyle e_{ij}( x) \ =\ \tilde{z}_{ij} -z_{ij}\) to be gap between the relative pose given by two states and the measured relative pose. (A number of blogs online do not define this way, but I think this would be a more efficient way for it has a simplier form of Jacobian).</p> </li> </ul> <h3 id="general-idea">General idea</h3> <p>Since we use a <em>graph</em> to optimize things, it is clear that we have to define two most important things in any kind of graphs: vertex and edge.</p> <ul> <li> <p>A vertex is a state, a random variable in probability, which needs to be optimized. In pose graph, it would be a state of pose \(\displaystyle x_{i}\).</p> </li> <li> <p>An edge is used to constraint two verteces. In pose graph, it could be a relative pose given by ICP matching. Notice that we do not optimize edges.</p> </li> </ul> <p>A nice metaphor is that consider all verteces are objectes connected by spring (edges), and at the beginning the system is loose and stable. Then we introduce some more spring to the system, and this makes almost all spring to be active (store a large amount of energy). The goal of optimization is to minimize this energy to make the system stable again.</p> <h3 id="define-loss">Define Loss</h3> <p>Our goal is to minimize all \(\displaystyle e_{ij}( x)\). Assume that \(\displaystyle e_{ij}( x) \ \sim \ \mathcal{N}( 0,\ \Omega _{ij})\), and all states are i.i.d., then it is equivalent to find the MLE:</p> \[G( e_{ij}( x)) \ =\ \prod _{i,j}\frac{1}{( 2\pi )^{3} |\Omega _{ij} |^{1/2}} \ \exp\left( -\frac{1}{2} e_{ij}^{T}( x) \Omega _{ij} e_{ij}( x)\right)\] <p>Notice that</p> \[\ln( G( e_{ij}( x))) \ =\ \sum \frac{1}{( 2\pi )^{3} |\Omega _{ij} |^{1/2}} \ -\ \frac{1}{2}\sum _{i,j} e_{ij}^{T}( x) \Omega _{ij} e_{ij}( x)\] <p>it would be the same to minimize</p> \[F( x) \ =\ \sum _{i,j} e_{ij}^{T}( x) \Omega _{ij} e_{ij}( x)\] <p>Of course, we can assume a distinct distribution, say Laplace distribution, and then the loss function would be different as above. In addtion, in order to make system robust to outliers, we can also apply Huber loss, which is widely used in Deep Learning:</p> \[Huber( e) \ =\ \begin{cases} \frac{1}{2} e^{2} , &amp; |e|\leq \delta \\ \delta \left( |e|\ -\ \frac{1}{2} \delta \right) , &amp; \text{otherwise} \end{cases}\] <p>To make things simple, we will assume Gaussian distribution.</p> <h5 id="q-what-is-displaystyle-omega-_ij-and-how-to-initialize-it">Q: what is \(\displaystyle \Omega _{ij}\) and how to initialize it?</h5> <p>A widely accepted answer is that \(\displaystyle \Omega _{ij}\) accounts for the uncertainty of the measurements, which is the inverse of the covariance matrix. Recall that measurements are obtained by ICP matching, thus we have a matched point set \(\displaystyle \{p_{i} ,q_{i}\}\) of two scans. And ICP algorithms give us a minimum value of the matching error</p> \[E(e_{ij}( x)) \ =\ \sum ||p_{i} \ -t2v( z_{ij}) *q_{i} ||_{2}^{2}\] <p>then we can find \(\displaystyle \Omega _{ij} \ =\ JJ^{T} \in \ M_{6}\), where</p> \[\displaystyle J\ =\ \frac{\partial E( e_{ij}( x))}{\partial e_{ij}( x)} \in \ \mathbb{R}^{6}\] <p>to be the Jacobian matrix.</p> <p>Of course, we can set it to identity or experimental values, there are more than one initialization.</p> <h3 id="main-process">Main Process</h3> <p>For the rest of the part, I advise you to look at the paper <a href="https://ieeexplore.ieee.org/document/5681215">A Tutorial on Graph-Based SLAM</a>.</p> <p>The reason why I do not write one myself is that currently all my ideas are inherited from that paper, i.e. I have not created some new ideas. Then it would be a nice choice to just provide the original paper to readers.</p> <p>But there’s one thing that I want to mention, it is that the gradient should instead be</p> \[\begin{array}{l} A_{ij} = \frac{\partial e_{ij}( x)}{\partial x_{i}^{T}} = \begin{bmatrix} -R_{i}^{T} &amp; \frac{\partial R_{i}^T}{\partial \theta _{i}}( t_{j} -t_{i})\\ 0 &amp; -1 \end{bmatrix}\\ B_{ij} = \frac{\partial e_{ij}( x)}{\partial x_{j}^{T}} = \begin{bmatrix} R_{i}^{T} &amp; 0\\ 0 &amp; 1 \end{bmatrix} \end{array}\] <p>since we have dropped \(z_{ij}\).</p> <h3 id="related-blogs">Related blogs</h3> <ul> <li><a href="https://github.com/xiaojxkevin/learning_slam/tree/main/pose-graph/project">Project of mine</a></li> <li><a href="https://blog.csdn.net/u010507357/article/details/108540110">blog-csdn</a></li> <li><a href="https://robotics.stackexchange.com/questions/22451/calculate-information-matrix-for-graph-slam">information-matrix</a></li> </ul>]]></content><author><name></name></author><category term="slam"/><summary type="html"><![CDATA[Notes of pose graph optimization]]></summary></entry><entry><title type="html">Clearing Disk Space on Ubuntu 22.04</title><link href="https://xiaojxkevin.github.io/blog/2024/clear-up-disk/" rel="alternate" type="text/html" title="Clearing Disk Space on Ubuntu 22.04"/><published>2024-03-14T00:00:00+00:00</published><updated>2024-03-14T00:00:00+00:00</updated><id>https://xiaojxkevin.github.io/blog/2024/clear-up-disk</id><content type="html" xml:base="https://xiaojxkevin.github.io/blog/2024/clear-up-disk/"><![CDATA[<h3 id="background">Background</h3> <p>The idea is simple, it is that I do not have enough disk space, since I only allocated around 90GB for my Ubuntu system. And in fact, there are a lot of abundant files that can be removed.</p> <p><strong>A Useful Command:</strong> <code class="language-plaintext highlighter-rouge">du -hx --max-depth=1 --threshold=800M</code>, which helps us find directories that takes up over 800MB, and these would be our targets.</p> <h3 id="root-">Root <code class="language-plaintext highlighter-rouge">/</code></h3> <ol> <li> <p>I first find out that there are a number of kernel instances in <code class="language-plaintext highlighter-rouge">/usr/lib/modules/</code>, and the fact is that I only need one or two of them. Then I follow the instructions in <a href="#reference">ref1</a> and obtain a few more GBs.</p> </li> <li> <p>Remove Snap (in fact I can find alternatives). Details are in <a href="#reference">ref2</a>.</p> </li> <li> <p>Big journels in <code class="language-plaintext highlighter-rouge">/var/log/journal</code>!. Details are in <a href="#reference">ref3</a></p> </li> </ol> <h3 id="home-">Home <code class="language-plaintext highlighter-rouge">~</code></h3> <ol> <li>I have been using <code class="language-plaintext highlighter-rouge">VSCode</code> since first year at college. Although it is great, there are quite a lot issues related to storage. <ul> <li> <p>Do you use the <code class="language-plaintext highlighter-rouge">cpp-extension</code> in VSCode? If yes, you may need to consider cpptools in <code class="language-plaintext highlighter-rouge">~/.cache/vscode-cpptools</code>. If you want to shorten the space usage of it, please go to settings and edit cache size.</p> </li> <li> <p>Please check <code class="language-plaintext highlighter-rouge">~/.config/Code/User/workspaceStorage</code>, it may also surprise you. See <a href="#reference">ref4</a> for more details.</p> </li> </ul> </li> </ol> <h3 id="reference">Reference</h3> <ul> <li><a href="https://serverfault.com/questions/1098556/how-to-cleanup-usr-lib-modules-and-usr-lib-x86-64-linux-gnu">ref1</a></li> <li><a href="https://sysin.org/blog/ubuntu-remove-snap/">ref2</a></li> <li><a href="https://askubuntu.com/questions/1238214/big-var-log-journal">ref3</a></li> <li><a href="https://www.jianshu.com/p/7497160db18b">ref4</a></li> </ul>]]></content><author><name></name></author><category term="system"/><summary type="html"><![CDATA[A Record of how I clear up disk space]]></summary></entry></feed>